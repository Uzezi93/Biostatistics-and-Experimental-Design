---
title: "Functions and Tidy Data"
author: "Uzezi Okinedo"
date: "10/5/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
# Loading all libraries

library(dplyr)
library(tidyr)
library(readr)
library(lubridate)
library(ggplot2)
library(forcats)
```

### <span style="color: red;"> Brilliant!! 41/33 points </span>

**1.** Write a function that takes a vector and returns one bootstrapped sample from said vector. Demonstrate that it works.

```{r function that takes a vector and returns one bootstrapped sample from said vector}

get_01_boot_samp <- function(vec){
  #get one bootstrapped sample from a said vector
   one_boot <-  sample(vec,
                    size = length(vec),
                    replace = TRUE)
  # return output
  return(one_boot)
   
}

#to demonstrate function with vole_vaso (a vector)
vole_vaso <- c(98,96,94,88,86,82,77,74,70,60,
           59,52,50,47,40,35,29,13,6,5)

# check if function works
get_01_boot_samp(vole_vaso)

```

### <span style="color: red;"> 3/3 points </span>

**2.** Write a function that given a vector of values a request for some number of bootstraps (let’s call the parameter R), and a sample statistic function (e.g., mean, IQR, etc.) returns R number of values of that statistic. Have it default to R = 1000 and the function is mean. Show this works for 10 bootstrapped replicate draws of a mean from some vector. Do the values look reasonable? Compare to the actual mean of the vector.

make sure you are using the function(s) you wrote in #1

```{r function to calculate a thousand bootstrapped means}

# function for a vector of values
# Request for a number of bootstraps (R)
# Set R = 1000 as default
get_01k_boot_mean <- function(vec, R = 1000) {
  
  # calculate bootstrapped mean of a sample
  # Use get_01_boot_samp() from question 1
  boot_mean <- replicate(R, 
                         mean(get_01_boot_samp(vec)))
  # return output
  return(boot_mean)
}

```

```{r test function}

# check if function works for 10 replicates of a sample
# set R = 10
get_01k_boot_mean(vole_vaso, R = 10)

  
```

The actual mean of the vector is 58.05. Therefore, these values look reasonable.

### <span style="color: red;"> 3/3 points </span>

**3.** Write a function that, given a vector of values a request for some number of bootstraps, and a sample statistic function, returns the original value of the statistic as applied to the vector, the mean of the statistic generated by the bootstrapped reps, the upper and lower 95% CI of the bootstrapped statistic (e.g., the 0.025 and 0.975 quantile), and the bias (i.e., the original value of the statistic - the mean of the bootstrapped statistic).
make sure you are using the function(s) you wrote in #1 and/or #2

```{r a special function}
# A function given a vector of values,
# request for some number of bootsraps (R)
# a sample statistic function
a_function <- function(vec, m, R = 1000) {
  # Returns the original value of the statistics (mean) 
  original_mean <- mean(vec)
  # returns the bootstrap mean using function created in question 2
  boot_mean <- get_01k_boot_mean(vec, R)
  # returns upper confidence interval
  upper_CI <- quantile(boot_mean, probs = 0.975)
  #returns lower confidence interval
  lower_CI <- quantile(boot_mean, probs = 0.025)
  # returns bias
  bias <- original_mean - boot_mean
  
  # define and summarise output
  out <- data.frame(original_mean = mean(vec), 
                    boot_mean = get_01k_boot_mean(vec, R), 
                    upper_CI = quantile(boot_mean, probs = 0.975), 
                    lower_CI = quantile(boot_mean, probs = 0.025),
                    bias = original_mean - boot_mean)
  
  return(out)
  
}

# test function on a vector (vole_vaso)
a_function(vole_vaso, R = 10)

```

### <span style="color: red;"> 3/3 points </span>

**4.** FiveThirtyEight keeps a great archive of poll data at https://projects.fivethirtyeight.com/polls/. The presidential general election polling data is freely available at https://projects.fivethirtyeight.com/polls-page/president_polls.csv with question, poll id, and cycle defining a unique poll.

**4a.** Download and look at the data. Is it long or wide?

```{r download the presidential election poll data}

# download president poll data 
download.file(url = "https://projects.fivethirtyeight.com/polls-page/president_polls.csv",
              destfile = "raw_data/president_polls.csv")

# read data into an object
president_polls <- read_csv("raw_data/president_polls.csv")

# view data
president_polls

```

This is a long data

### <span style="color: red;"> 3/3 points </span>

**4b.** Get just the polling data for this last week (from 9/29 to today). Filter on start_date. Also filter down to just Biden and Trump (see candidate_name or answer). Extra credit for using {lubridate} for this, but you can just do a messy %in% string match.

```{r polling data for this last week}

# Covert "start_date" column to Date using lubridate
president_polls$start_date <- as.Date(president_polls$start_date, format = "%m/%d/%Y")

polls <- president_polls %>%
  #filtered start dates from 9/29 and above and selected "Donald Trump" and "Joseph R. Biden"using lubridate.
  filter(start_date >= "0020-09-29") %>%
  filter(candidate_name %in% c("Donald Trump", "Joseph R. Biden Jr."))

# view polls
polls

```

### <span style="color: red;"> 3/3 points </span>

**4c.** OK, this is your sample. What’s the bootstrapped average percentage for each candidate for nationwide polls (state == "")? Note, this answer will not match 538 given their weighting by poll trustworthiness.

```{r bootstrapped average percentage for each candidate nationwide}

# created a wide dataframe and made seperate columns for each candidate with values from the average national polls as the rows.

polls_wide <- polls %>%
  # pivot wider function
  pivot_wider(names_from = candidate_name,
              values_from = pct,
              values_fill = list(density = 0))

# to get the bootstrapped average percentage for each candidate
polls_wide %>%
  
  # group by state
  group_by(state) %>%
  # determine bootstrapped average percentage for each candidate using function from question 2
  summarise(boot_avg_pct_trump = get_01_boot_samp(mean(`Donald Trump`, na.rm = TRUE)), boot_avg_pct_biden = get_01_boot_samp(mean(`Joseph R. Biden Jr.`, na.rm = TRUE)))
  
```

### <span style="color: red;"> 3/3 points </span>

**4d.** What is the average difference between the two candidates by state and national polls? Note, you’ll need to make this a wide data frame to answer! And, well, try the pivot without this advice first, but then….

make a unique ID by pasting together the question_id, poll_id, and state. Then select the ID, state, answer, and pct. Also filter out NA diffs

```{r average difference between the two candidates by state and by national polls}

# make a unique ID by pasting together question_id, poll_id and state using mutate and paste
new_polls_wide <- polls_wide %>%
  group_by(state) %>%
  mutate('question_id-poll_id-state' = paste(as.character(question_id), as.character(poll_id), as.character(state), sep = "_")) %>%
  # group new dataframe by new ID
  group_by(`question_id-poll_id-state`) %>%
  # calculate average differences between the two candidates nationwide
  summarise(Trump = na.omit(`Donald Trump`), Biden = na.omit(`Joseph R. Biden Jr.`), difference = Trump - Biden, average = (Trump + Biden)/2, avg_difference = difference/average)

# view data with average differences
new_polls_wide

```

### <span style="color: red;"> 3/3 points </span>

**5.** replicate() has been our friend, but we’ve always had to be a little hacky with it. We’ve either had to fold in means, or use tricksy functions like colMeans and the like.

BUT - what’s interesting about replicate() is that, if you ask it to turn back raw draws from a random number generator - or anything with more than one value - it gives you a matrix or array.

**5a.** So, I want you to, using the mean and SD of Biden’s national polling average (you’ll need to calculate it!) from above, simulate 1000 draws from that population with a sample size of 50. What are the dimensions of the object. What are in the rows and columns?

```{r simulation of Biden average polls}

# extract Biden's polling averages from national polling data
biden_avg_polls <- new_polls_wide %>%
  group_by(`question_id-poll_id-state`) %>%
  # filter out all NA from Biden's polls
  filter(!is.na(Biden)) %>%
  # pull out Biden's polling average
  pull(Biden)

# view Biden's polls
biden_avg_polls

# calculate the mean and SD of Biden's polls
mean_biden_avg_polls <- mean(biden_avg_polls)
SD_biden_avg_polls <- sd(biden_avg_polls)

# set seed for reproducible bootstraps
set.seed(123)

# generate a sample size of 50 with mean and SD of Biden's average polls
samp <- rnorm(50, mean_biden_avg_polls, SD_biden_avg_polls)

# simulate 1000 draws
samp_draws <- replicate(1000,
                      sample(samp,
                             size = length(samp),
                             replace = TRUE))
# view simulated draws
samp_draws

# Check the structure of the draws
str(samp_draws)

# check the dimension of the draws
dim(samp_draws)


```

Rows contain simulations while column represents each simulated draws of the mean.

The dimension of the object is 50 by 1000.

### <span style="color: red;"> 3/3 points </span>

**5b.** Yuck. Can you turn this into something usable? Say, first make it a tibble or data frame, and then pivot it to long, such that you end up with a column that has an identifier for sim and a column with a single value from that sim?

(Oh, and for all columns, cols = everything())

```{r make 5a usable}

# convert the matrix of simulated draws to a long dataframe
samp_draws_long <- as.data.frame(samp_draws) %>%
  pivot_longer(cols = everything(),
               # give column names
               names_to = "simulation",
               values_to = "boot_mean")

# view data frame
samp_draws_long
  
```

### <span style="color: red;"> 3/3 points </span>

**5c.** For each sim, what’s the bootsrapped mean and CI? Plot it! And tell us how often it’s greater than the initial mean. E.C. for the plot showing the stats in order from low to high.
  
```{r plot boot mean and CI}

samp_draws_long %>%
  # For EC; Use mutate and fct_reorder function to sort stats in order from low to high
  mutate(ordered_simulation = fct_reorder(simulation, boot_mean)) %>%
# use ggplot to plot the bootstrapped mean and CI for each simulation
ggplot(aes(x = ordered_simulation, 
           y = boot_mean,     # setting ggplot mapping and aes
           alpha = 0.2)) +
  stat_summary(fun.data = "mean_cl_boot") +
  # To indicate the initial mean on the plot
  geom_hline(yintercept = mean(biden_avg_polls), linetype="dotted", 
                color = "red", size=1) +
  labs(x = "Simulations", y = "Bootstrap mean", title = "Biden's Bootsrap means at 95% CI")
  

```

```{r how often is it greater than the initial mean}

# determine the length of all boot means greater than the initial mean (49.63147)
greater_than_mean_boot <- samp_draws_long %>%
  select(boot_mean) %>%
   filter(boot_mean > 49.63147)

# calculate the probability of of having a boot mean higher than the initial mean
prob_of_higher_boot <- length(greater_than_mean_boot)/length(samp_draws_long$boot_mean)

prob_of_higher_boot


```
The bootstrapped mean is greater than the initial mean 2e-05 of the time.

### <span style="color: red;"> Amazing plot! 5/3 points </span>

**5d.** So…. what is that plot showing? What are the concepts involved?

The plot shows the bootstrap mean for each simulation at an interval of 95%. The concept involves estimating the bias or variance between each bootstrapped mean and the original mean in order to estimate prediction errors.

### <span style="color: red;"> 3/3 points </span>

**EC** 3 bonus point for each awesome quality visualization of the general polling data. There is a LOT there, so look carefully before you leap.

```{r visualization of the general polling data}

# visualization of the general polling data for Trump and Biden

trump_biden <- president_polls %>%
  # filtered out Trump and Biden's polling data
  filter(candidate_name %in% c("Donald Trump", "Joseph R. Biden Jr."))
# plot average polling percentage nationwide for each candidate
  ggplot(data = trump_biden,
         mapping = aes(y = pct,
             fill = candidate_name,
             colour = candidate_name)) +
    geom_boxplot() +
  labs(y ="Percentages",
     title = "General polls for Trump and Biden")

```

```{r visualization of the general polling data of Trump and Biden by start dates}

# plot a smooth curve for both candidates by start dates
ggplot(data = trump_biden,
         mapping = aes(x = start_date,
                       y = pct,
                       colour = candidate_name)) +
  geom_smooth() +
  labs(x = "start date", y ="Percentages",
     title = "General polls for Trump and Biden by start dates")
```

### <span style="color: red;"> Beautiful and incredible plots! 6/6 points </span>

[GitHub Extra Credit](https://github.com/Uzezi93/BIOL-607-Homework-Fall-2020-/blob/master/04_OKINEDO_UZEZI_2020.md) 


